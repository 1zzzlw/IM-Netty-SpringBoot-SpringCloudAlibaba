### 一、HTTP 握手阶段（建立连接时，仅执行一次）

此时客户端发送的是 HTTP 升级请求，属于**入站事件**，执行顺序：① → ② → ④ → ⑤

1. **① IdleStateHandler**

   先触发（但此时刚连接，还没到 30 秒空闲，暂时无动作），仅作为 “前置监听器” 存在，不影响后续 HTTP 处理。

2. **② HttpServerCodec**（核心 HTTP 编解码）

    - 入站：将底层字节流解码为 `HttpRequest`（HTTP 请求对象，包含升级头信息）。
    - 此时还未涉及出站，编码器暂不工作。

3. **④ HttpObjectAggregator(8192)**（HTTP 消息聚合）

   接收 ② 解码后的 `HttpRequest` 片段，聚合成完整的 `FullHttpRequest`（确保拿到完整的升级请求头），传给下一个处理器。

4. **⑤ WebSocketServerProtocolHandler("/ws")**（握手核心）

   接收 ④ 聚合后的完整 `FullHttpRequest`，验证是否是路径为 `/ws` 的 WebSocket 升级请求（检查
   `Upgrade: websocket` 等头）：

    - 验证通过：返回 HTTP 101 响应（通过 ② 的 HttpResponseEncoder 编码发送，属于出站，此时出站顺序是 ⑤ →
      ②），完成握手，连接升级为 WebSocket。
    - 验证失败：返回错误响应，结束流程。

### 二、WebSocket 通信阶段（握手成功后，持续执行）

此时通信协议切换为 WebSocket，收发数据为帧（`WebSocketFrame`），分 “入站接收” 和 “出站发送” 两种情况：

#### 1. 入站事件（前端发消息到后端）

执行顺序：① → ② → ⑤ → 自定义业务处理器（你后续加的）

- **① IdleStateHandler**

  持续监听：若 30 秒内没收到前端数据，触发 `IdleState.READER_IDLE` 事件（可用于检测客户端断线），事件继续向后传递。

- **② HttpServerCodec**

  此时已升级为 WebSocket，HTTP 解码器不再工作（跳过），仅作为 “通道” 传递字节流给下一个处理器。

- **⑤ WebSocketServerProtocolHandler**（核心帧解析）

  接收字节流，自动解析为 `WebSocketFrame`（文本帧 / 二进制帧），并过滤掉控制帧（如 ping/pong/
  关闭帧，自动处理），只将业务帧（文本 / 二进制）传给后续处理器。

- 最终到你的**自定义业务处理器**，解析 `WebSocketFrame` 中的数据（如文本帧的字符串），处理业务逻辑。

#### 2. 出站事件（后端发消息到前端）

执行顺序：自定义业务处理器 → ⑤ → ③ → ②

- 自定义业务处理器：将业务数据封装成 `WebSocketFrame`（如 `TextWebSocketFrame`），调用
  `ctx.writeAndFlush()` 触发出站。

- **⑤ WebSocketServerProtocolHandler**

  接收 `WebSocketFrame`，确认格式合法后，传递给前一个出站处理器。

- **③ ChunkedWriteHandler**

  若发送的数据是大文件 / 大数据流（如二进制帧内容很大），自动分块发送，避免内存溢出；小数据则直接通过。

- **② HttpServerCodec**（的 HttpResponseEncoder）

  此时已升级为 WebSocket，HTTP 编码器不处理帧，仅将帧的字节流写入底层通道，发送给前端。

- **① IdleStateHandler**：不处理出站事件，直接跳过。

### 总结核心顺序逻辑

- **入站（收数据）**：按添加顺序（①→②→④→⑤→自定义），前四步完成握手 + 帧解析，最终到业务逻辑。
- **出站（发数据）**：按添加逆序（自定义→⑤→③→②），核心是⑤封装帧、③处理大数据、②输出字节流。

每个处理器各司其职，从 “连接握手” 到 “持续通信” 无缝衔接，前面的处理器为后面的铺路，逻辑很连贯。

2025-11-19
今天晚上是学习的Netty，从昨天开始入手的，刚开始思路挺乱的，想写好，但是无能为力，当时只是写过一个小Demo，
小Demo里的Netty其实没什么含金量，只是引入框架就可以使用了，然后就想开始了解别人怎么写的，刚开始确实有点
懵，但是硬着头皮看下去了，然后看懂了，但是对我自己项目的Netty结构如何规划还是不太清晰，今天一下午开始看
Netty的最规范的优秀代码实现，然后有了思路，自己写了自定义消息编码解码器，然后慢慢的，有了灵感，规划好了
Netty的框架，问了一下ChatGPT，说我的框架是企业级的，很专业，挺好的，挺激动的，就是没人分享。

2025-11-20
Netty的基础框架已经完美实现了，我感觉还挺不错的，现在只是实现了私信的功能，实现的应该是非常规范的，现在
已经是我的极限了。后面就要开始陆续完善各个功能了，搭建好Netty的框架，我感觉那些功能要实现起来也不难了，
至少不是很麻烦了。

下面开始罗列一下要实现的功能，以及实现思路，因为想要实现的功能挺多的，尤其是对于数据库的创建，很麻烦，我
的数据库表独自创建的次数不是很多，所以很繁琐的关系我自己会绕晕，需要提前规划一下了，现在我就创建了5个表
分别是，消息表，好友关系表，用户信息表，用户主要信息表，好友申请表。后续还需要加上会话表，私信会话表，群
聊会话表，群成员信息表等等吧。

首先先从简单的开始吧

好友申请的及时通知，目前还没有实现消息提示框的思路，这个需要前端努力了，我还没有实现思路，所以就只关心前端
传递，后端接收的Handler处理就可以了。所以实现起来并不难，并且前端的二进制协议的发送和接收都设置正确了

创建群聊功能，这个时候就需要去完善一下数据库了，会话表，群聊会话表，群成员信息表，都需要创建，想明白表之间
的关系在写吧。代码实现也不难，先是Http请求，操作数据库，将一下信息写在数据库中。然后需要ws请求通知群成员
是否选择加入群聊，和好友申请的及时通知差不多。加入时候，聊天发送和私信发送一样，需要注意前端设置的消息类型
-- 现在开始设计群聊实现思路了，因为要创建一个会话表，所以这次设计思路我感觉不是一下子就能想出来的，感觉有点
复杂，我想到的是，还是先查好友表，拿到该用户的好友id，循环遍历还是同意的方法，遍历得到所有的会话id，此时放在
一个集合中。然后前端传输这个集合到后端。用集合来查询会话表，会话表和私信会话表联表查询。这就是后端的工作了。
至于好友信息，查询好友列表的接口那一步就返回了，就不用考虑了。所以整个过程梳理下来之后不是很复杂，总结一句话
就是，查询会话表就是为了拿到这个会话的状态并且只显示会话表中存在的会话。至于会话的各种状态，如置顶，删除，其中
删除只是把会话从会话列表中删除，不会从数据库中删除，只有删除好友的时候才会从数据库中删除，删除是修改数据库中的
status来判断是否在会话列表中中展示，后端只需要管好传过去状态，前端来判断。
-- 数据库表我现在想到最新的设计思路了，就是会话表的作用我想改进一下了，因为每个人的会话状态都是不同的，所以一个会话id
可能有两个状态，所以如果要是细分的话，群聊和私信都需要单独设置这些会话自动就重复了，所以我觉得会话表的会话id是不唯一的，
私信就可以存2个，需要加上用户id，id1在2_1的会话中，id2，也在会话id为2_1的这样子。群聊会话表和这个类似，因为群聊有特殊的字段，
比如名称，头像，用户数量等，这些有的是群主才能修改的。但是就不用加用户id了，因为有群成员表，在这里面写状态
-- 设计群聊创建，需要注意Netty的及时通信也要加上，感觉是比较麻烦的，因为群聊创建的时候，需要通知群成员，
这就需要在Netty中实现及时通信，这就需要在Netty中实现一个群聊的Handler，还有发送消息的时候，也需要通知群成员。
我好像没有思路了。

然后就是用户上线功能了，这一功能需要修改redis中的online值，我现在是感觉数据库应该不需要存储online，毕竟
online只是临时的数据，这个功能我认为直接完美实现吧，前端也要有优化，我的优化思路是和QQ差不多的，用户头像
右上角带上绿色的小圆圈，亮起来就是在线，灰色就是不在线。并且用户头像也要跟着变色。并且还要写electron的Tray
的托盘图标了，并且也要设置离线和在线状态，并且还要设置网络断开用户断线的功能，这个估计要和心跳有关联，也可以
在设计一个Handler。

未读消息数量展示在会话列表中，小数字标，这个的实现思路还没有想好

最后消息展示，最后发送消息的时间展示，文件发送，撤回消息，引用消息，删除消息，收藏消息，置顶，删除会话列表等等
这些小功能只要能想到都可以随时加上

这些功能实现之后就可以着手优化前端了，算是美化前端页面吧，还要补异常处理类，后端功能完成也有很多我需要优化的
地方。还有忘记密码功能，这个到时候写密码加密的时候在写吧

然后是视频通话，语音聊天，前端表情包。等等，最后还有个大工程，朋友圈。

还有的优化，pinia的本地存储，阿里云OSS云服务存储头像等等

还要导入DeepSeek大模型依赖，引入机器人聊天功能

完成这些我估计还需要一个月作用，本来打算12月份之前完成呢，看来是要1月份之前了，只能寒假的时候再去学习分布式
微服务了，到时候在分布式微服务的架构优化项目，加上消息队列，实现异步通信，提高系统的吞吐量和响应速度。

最后项目就完美实现了，多余时间可以在开发一个uniapp，实现跨平台的应用，包括移动端和PC端。

-- 写完之后的感受
好友申请：新建窗口直接不能共享ws连接，花了我5个小时处理，想办法解决，快崩溃了，后端修改完善了一点，花的时间
不长，主要是前端的electron的渲染通信，还是不熟悉，如果特别熟悉的花就不会花太多时间了。现在说一下当时的解决
思路，首先由于新建窗口为添加好友的窗口，此时是一个完全新的窗口，没有ws连接，所以我将信息内容通过预渲染进程发
送给了主进程，主进程拿到信息后，在通过预渲染进程将信息发送给其中一个渲染进程，我觉得这个渲染进程是哪个都可以
但是为了统一，我选择了main.js渲染进程，其实我觉得应该是在哪里连接就放哪里的，之前我的初始化连接是放在了main
.js里面，但是由于后端管理用户信息的集合，如果项目启动就连接到ws，有一种情况会出现bug，就是redis中并没有此时
要登录的用户信息，然后此时连接传入的token就是本地electron-store中的旧token或者空值，是空值还好就会报错，
如果不是空值，就相当于拿到了上一个登录用户的信息来登录。这个bug很容易发现。所以我又把连接转移到了主窗口里面，
在主窗口里面连接ws，就不会出现这个问题了，因为登录成功之后在去连接，electron-store里面的信息已经更新了

-- 目前写到了文件发送，有了大致的前端发送后端接收的思路
前端的相关的功能有截图，文件，文本。目前只考虑这三种，其中文件又包含图片，视频，文件。所以前端就需要根据后缀来
判断是哪种消息类型，其中截图是图片，可以直接上传到服务器，文件就需要前端写一个专门的根据后缀判断文件类型的函数
然后在去调用发送消息的函数上传至服务器，服务器收到消息的时候，首先判断是单聊还是群聊，如果是单聊，那么就要在
单聊的handler中判断消息类型，如果是文本，则直接处理发送。如果是文件，则需要接着转发到文件的handler中处理
这就是大致思路，但是文件的发送细节我还没怎么了解过

-- 目前又发现了很多的问题，首先是我了解到了消息编码解码器是有外部工具的Protobuf的，我是用的自定义的消息编码
解码器自己设置的魔数等标识，但是效果还是不如Protobuf好，所以后面的优化内容又要考虑Protobuf了。然后是文件的
发送，比我想象中的复杂，所以我想暂时搁置一段时间项目的写作，我准备一段时间去学习文件的传输注意事项，优化实现
以及webrtc的传输方式来判断哪种方式更合理，感觉文件传输这一部分要花费我四五天了，群聊那部分我自己计划的估计也
是要一周以内的时间吧，全部功能完成估计一月份之前够呛，但是也能完成个80%，90%吧。

-- 目前文件发送的写作思路，首先说一下最终的目标，文件发送要实现断点续传，进度条实时展示，webrtc和websocket
两种方式的速录控制，多文件同时传输，传输状态反馈。
现在刚刚开始写，以及有了大致的思路，首先我要先完成http协议的文件上传功能，先从最简单的开始，我的思路是，http
只是负责传输文件的信息，所以传输速率会很快，等待后端的响应，然后将传输的文件复制一份到前端指定的文件存储目录里
所以我的前端点击发送的时候，需要直接将发送内容展示在聊天窗口上，然后再去调用http的发送接口方法传递给后端，其中
发送的信息有文件的基本信息，比如文件名，文件大小，文件类型，文件路径等。尤其是文件路径，我目前认为应该是前端设
置的存储目录，文件名我觉得前端需要重新生成一个，然后就可以等待后端的响应，响应成功就需要复制文件到指定的目录，
响应失败就需要展示感叹号。此时本地就有了一个文件，然后ws协议就要开始传输文件，但是如果不进行特殊处理，当对方不
在线的时候，这个文件就会发送失败，所以需要添加一个对方同意接收文件的功能，所以，ws的第一次传输也是传输文件的
大概信息，不过需要传递的信息和首次不同，如果是图片，那么就传输缩略图，视频也是缩略内容包括第一帧画面，文件只传输
信息就够了，因为不需要展示。然后用户点击图片如果要高清图，就需要下载，如果要观看视频也需要先点击下载，文件也是
需要点击下载。点击下载按钮之后，就再次发送一个ws协议从对方的客户端获取，就可以根据对方的本地路径存储位置传输文件
，但是这个的前提也是需要发送方此时在线，处理方式就是需要临时存储在云服务器中，然后设置过期时间

-- 文件发送前期的功能完成，发送并展示在聊天窗口上，思路有一些修改。其中选择文件，获得文件的名称，raw二进制流，
首先是使用electron直接用fs创建根据日期命名的文件夹，然后复制。文件路径用户自定义设置，使用electron-store存
储，但是所以是在http请求发送之间就已经完成了本地复制，而且传给后端的我文件内容是前端根据文件类型映射的'[图片]，
'[文件]','[视频]'，这样的content。不过为了能够展示出来，此时的过渡阶段使用MySQL临时存储文件的存储路径，方便
展示在前端。接下来一步就是通过ws实时传输给对方了。那么，这个我觉得直接一步到位比较好，前端直接解析分块传输的操作
后端解析分块接收。首先我提前知道的就是，我这种方式的文件发送，需要对方在线才可以，当时的解决思路是等待对方点击接收
在用ws传输。所以，文件发送的ws传输需要分开写两次，首次是把文件的基本信息传递过去，无论是图片还是视频，都要传递一个
压缩内存的文件内容，对方选择接收的时候才会展示清楚的文件内容。然后下面是我目前的思路，后端的写一个Handler处理文件
简单信息的发送，发送给对方的客户端，前端代码就是，接收，展示在聊天窗口上。同样是使用的messageStore的缓存的更新展
示的，所以缓存的还是文件路径。但是缩略图也需要存储啊，不然对方离线的话也是不能展示，好吧，我感觉必须使用MQ才能解决
对方离线的时候发送文件了。······，经过一些时间，我了解到了一下minio作为图片，视频的存储。我发现我目前还没有办法去
解决这些问题，还需要学习一些东西才可以，所以现在的文件发送，我认为，只要实现双方都在线的情况下，能够实现分块传输就
可以了。

-- 大概花了三天时间吧，看了看一个微服务的项目里面有minio的使用，慢慢的有了文件发送的整体路线

一：初步的实现，只使用MySQL数据库，数据库里的消息表，内容需要存储本地存储的文件路径，必须要存储这个，否则我认为很麻
烦也不利于以后的扩展优化，这样就可以实现基础的实时接收，但是需要保证双方都在线，用户A发送给用户B，B就直接接收并保存在
本地的存储路径中了，这样也算是永久存储了，但是缺点就是，不能实现离线接收，即使我添加用户自主接收文件的功能按钮，也不
可以，并且查询速录会随着数据库中的数据增多而越来越差

二：使用SQLite3，目前我还有没学习过，也没有入门过，但是只是了解过，感觉和数据库差不多只不过是本地存储的，我现在只知道
他的查询速率肯定是比MySQL好的，比较不需要发送网络请求，然后他的消息表中还是需要存储文件路径，但是缺点还是没有实现，还是
不能离线的情况下接收文件，会导致文件的丢失。只是一个优化查询效率的一个功能

三：加入Minio，相当于一个云服务器了吧，云存储，使用的话就可以实现离线接收文件了，实现思路是用户A发送文件判断对方在不在线
不在线就暂时发送给Minio，直到对方上线，可以选择前端监听对方上线看是否有待接收的文件然后自动接收，这个判断可以加入文件的大
小，也可以选择手动接收，这样就可以在用户B离线的情况下发送文件保证文件不丢失的功能了，缺点的话应该就是图片，视频都需要依赖它

四：开始使用MQ消息队列，MQ消息队列直接就可以实现消息的离线发送，我的文本消息离线实现其实只是通过MySQL实现的，因为即使对方
不在线，http协议仍然会发送给本地数据库增添数据，这种方式后期肯定是需要优化的，如果用户量过多，操作这一个数据库肯定不行，
然后是对方上线的时候，但是我感觉后期加入SQLite3本地存储的话应该还好。目前还没有学习SQLite3，暂时还想不出来对比情况怎么样，
然后是使用MQ消息队列+redis的话肯定可以实现高效率的离线发送，然后就可以和Minio混合使用了，文件一般内存都很大，就使用Minio，
像图片，文本消息之类的就可以使用MQ。

五：加入webrtc功能，这个就必须要双方都在线才可以了，所以可以当作一个扩展功能，当对方在线的时候，发送方可以选择高速和普通的传输
方式，选择高速就是使用webrtc来传输
